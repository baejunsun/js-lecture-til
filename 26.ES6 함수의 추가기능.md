# ES6 함수의 추가 기능

es6이전까지 함수는 모두 일반함수,생성자 함수로서 호출할수 있다.

모두 callable, constructor

메소드로 만든 일반함수를 생성자함수로 호출 했을때 불필요한 프로토타입객체를 생성하게 된다. 함수에 전달되어 보조 역할만을 수행하는 콜백 함수도 마찬가지이다.

ex6이전의 모든 함수는 사용 목적에 따라 명확한 구분이 없으므로 호출 방식에 특별한 제약이 없고 생성자 함수로 호출되지 않아도 프로토타입객체를 생성한다. 실수유발



## 메소드

- es6이전의 메소드는 객체에 바인딩된 함수를 일컫는 의미로 사요오디었다

- es6사양에서 메소도는 메소드 축약 표현으로 정의된 함수만을 의미한다. non-constructor로 인스턴스를 생성할 수 없으므로 prototype프로퍼티가 없고 프로토타입도 생성하지 않는다.

*표준 빌트인 객체의 메소드는 모두 non-constructor

- es6 메소드는 바인딩된 객체를 가리키는 내부슬롯 [[HomeObject]]를 갖는다. super키워드로 참조하면 내부슬롯 [[HomeObject]]사용하여 수퍼클래스의 메소드를 참조하므로 [[HomeObject]]를 갖는 es6메소드만이 super를 사용할수있다.



## 화살표함수

표현방법, 내부동작이 기존의 함수보다 간략하다. 콜백함수에서 this가 전역객체를 가리키는 문제를 해결

### 화살표 함수 정의

1.매개변수 선언

- 매개변수가 여러개인경우 소괄호안에 매개변수를 선언 (x,w) =>{}
- 매개변수가 한개인 경우, 소괄호()를 생략할 수 있다. x =>{}
- 매개변수가 없는 경우, 소괄호를 생략할수 없다. ()=>{}

2.함수 몸체 정의

- 함수몸체가 한줄의 문으로 구성 된다면 중괄호를 생략할수 있다. 한줄의 문은 return없이 암묵적으로 평가되어 반환
- 여러줄로 되어있으면 중괄호를 생략할수 없고, return으로 반환값을 명시해주어야 한다.
- 객체 기터럴을 반환하는 경우, 객체 리터럴을 소괄호로 감싸주어야 한다
- 화살표 함수도 즉시 실해 함수로 사용할 수 있다.
- 화살표함수도 일급객체

### 화살표 함수와 일반 함수의 차이

- 화살표 함수는 인스턴스를 생성할수 없는 non-constructor
- 중복된 매개변수 이름을 선언할 수 없다. 에러
- 화살표 함수는 함수자체의 this, arguments, super,new.target 바인딩을 갖지 않는다. = 따라서 참조하면 스코프체인을 통해 상위 컨텍스트로 가서 참조한다.

### this

콜백함수내부의 this문제를 해결하기 위한 3ㅏ깆 방법

- 메소드를 호출한 prefixer객체를 가리키는 this를 일단 회피시킨 다음 콜백 함수내부에서 사용한다.
- Array.prototype.map의 2번째 매개 변수에 메소드를 호추랗 객체를 가리키는 this를 전달한다
- Function.prototype.bind 메소드를 사용하여 메소드를 호출한 객체를 가리키는 this를 바인딩한다.

화살표 함수의 경우

- 화살표 함수는 this 바인딩이 없다. 화살표 함수의 경우 this를 참조하면 상위 스코프의 this를 참조하게 된다. = Lexical this라 한다. 렉시컬 스코프와 같이 정의 된 위치에 따라서 this가 결정된다.
- 화살표 함수 내부의 this는 call,apply,bind를 통하여 변경할수 없다.무시된다. 엄밀히 말하면 사용할수 없는게 아니라 this가 일단 결정된 이후 변경할수 없고 유지된다.
- 메소드를 화살표 함수로 정의하는 것은 피해야 한다. =>this가 상위스코프의 this로 결정되기 때문
- 위와같은 이유로 프로토타입 객체에 메소드를 추가할때도 화살표 함수를 쓰는것을 피해야 한다.
- 클래스필드정의제안을 사용하여 클래스 필드에 화살표 함수를 할당할 수도 있다. -> 상위스코프는 constructor이며 constructor의 this는 생성할 인스턴스이다. -> 하지만 프로토타입 메소드가 아니라 인스턴스 메소드가 된다. -> es6 메소드축약 표현을 쓰는게 좋다.

### super

super도 this와 마찬가지로 상위 컨텍스트의 super를 참조한다.

### arguments

arguments도 this와 마찬가지로 상위 컨텍스트의 arguments를 참조한다.

상위 컨텍스트의 arguments 참조로는 화살표함수에 전달된 인수 목록을 확인할수 없으므로 도움이 되지 않는다. 

따라서 화살표 함수로 가변 인자 함수를 구현해야 할때는 반드시 rest파라미터를 사용해야 한다.



## Rest파라미터

### 기본문법(나머지 매개변수, ...rest)

*rest파라미터는 매개변수 이름 앞에 세개의점을 붙여서 정의한 매개변수를 의미한다. rest파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받는다.*

- rest파라미터는 반드시 마지막이어야 한다. 에러
- rest파라미터는 단 하나만 선언할 수 있다.
- rest파라미터는 함수객체의 length 프로퍼티(매개변수개수를 나타내는 함수)에 영향을 주지 않는다.

### rest파라미터와 arguments 객체

argument는 함수호출시 전달된인수들의 정보를 담고 있는 순회가능한 유사배열객체이다. 함수내부에서 지역변수처럼 사용할수있다.

- 배열메소드 사용시 메소드의 this를 arguments로 변경해서 호출해야 하는 번거로움이 있다.(인수를 전달받는 것이 불가능하기 때문이다.)
- rest파라미터를 사용하면 가변인자 목록을 직접 배열로 전달받을수있다. arguments에서 객체를 배열로 변환하는 번거로움을 피할수 있다.
- 일반 함수와 메소드는 rest파라미터와 arguments객체를 모두사용할수있다
- 화살표함수는 arguments객체를 갖지 않는다. 가변인자함수를 구현시 rest파라미터를 사용해야한다.



## 매개변수 기본값

자바스크립트는 매개변수 개수와 인수의개수를 체크하지 않는다 

= 같지않아도 에러 x

= 적절한 인수가 전달되었는지 함수내부에서 확인할 필요가 있다.

= 방어 코드가 필요하다 



*es6에서는 매개변수 기본값을 사용하여 함수 내에서 수행하던 인수 체크 및 초기화를 간소화할 수 있다.*

- 매개변수 기본값은 매개변수에 인수를 전달하지 않았을 경우와 undefined를 전달한 경우에만 유효하다
- rest파라미터에는 기본값을 지정할 수 없다. 에러
- 매개변수 기본값은 함수객체의 length프로퍼티와 arguments객체에 영향을 주지 않는다.

## 

