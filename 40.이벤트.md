# 40.이벤트

## 1.이벤트 드리븐 프로그래밍

이벤트가 발생했을 때 호출될 함수를 **이벤트 핸들러(event handler)**

이벤트가 발생했을 때 브라우저에게 이벤트 핸들러의 호출을 위임하는 것을 **이벤트 핸들러 등록**

프로그램의 흐름을 이벤트 중심으로 제어하는 프로그래밍 방식을 **이벤트 드리븐 프로그래밍(event-driven programming)**이라 한다.

## 2.이벤트 타입

## 3.이벤트 핸들러 등록

### 3.1 이벤트 핸들러 어트리뷰트 방식

- HTML 요소의 이벤트 핸들러 어트리뷰트 값으로 함수 호출문 등의 문(statement)을 할당하면 이벤트 핸들러가 등록된다.
- 함수참조가 아닌 함수 호출문 등의 문을 할당

### 3.2이벤트 핸들러 프로퍼티 방식

- 이벤트 핸들러 프로퍼티에 함수를 바인딩하면 이벤트 핸들러가 등록된다.
- 이벤트 핸들러 프로퍼티에 하나의 이벤트 핸들러 만을 바인딩할 수 있다는 단점이 있다.

### 3.3 addEventListener메소드 방식

- 첫번째 매개 변수에는 이벤트의 종류를 나타내는 문자열인 이벤트 타입을 전달한다.
- 두번째 매개변수에는 이벤트 핸들러를 전달한다
- 지막 매개 변수에는 이벤트를 캐치할 이벤트 전파 단계(캡처링 또는 버블링)를 지정한다. 생략하거나 false를 지정하면 버블링 단계에서 이벤트를 캐치하고 true를 지정하면 캡처링 단계에서 이벤트를 캐치한다. 
- 하나 이상의 이벤트 핸들러를 등록할 수 있다. 이때 이벤트 핸들러는 등록된 순서대로 호출된다.
- 참조가 동일한 이벤트 핸들러를 중복 등록하면 하나의 이벤트 핸들러만 등록된다.

## 이벤트 핸들러제거

- addEventListener 메소드로 등록한 이벤트 핸들러를 제거하려면 EventTarget.prototype.removeEventListener 메소드를 사용한다.
- removeEventListener 메소드에 전달할 인수는 addEventListener 메소드와 동일하다.
- addEventListener 메소드에 전달한 인수와 removeEventListener 메소드에 전달한 인수가 일치하지 않으면 이벤트 핸들러가 제거되지 않는다.
-  동일한 참조를 갖는 함수이어야 한다. 따라서 아래와 같이 무명 함수를 이벤트 핸들러로 등록한 경우, 제거할 수 없다.
- 단, 이벤트 핸들러 내부에서 removeEventListener 메소드를 호출하여 자신을 제거하는 방법은 가능하다. 이때 이벤트 핸들러는 단 한번만 호출된다.
- 기명 함수를 이벤트 핸들러로 등록할 수 없다면 호출된 함수, 즉 함수 자신을 가리키는 arguments.callee(“18.2.1. arguments 프로퍼티” 참고)를 사용할 수도 있다.
- 이벤트 핸들러 프로퍼티 방식으로 등록한 이벤트 핸들러를 제거하려면 이벤트 핸들러 프로퍼티에 null을 할당한다.

## 5이벤트 객체

- 이벤트가 발생하면 이벤트에 관련한 다양한 정보를 담고 있는 이벤트 객체가 동적으로 생성된다. 
- 생성된 이벤트 객체는 이벤트 핸들러의 첫번째 매개 변수에게 전달된다.

### 5.1이벤트 객체의 상속구조

- 이벤트가 발생하면 발생한 이벤트의 타입에 따라 다양한 타입의 이벤트 객체가 생성된다. 
- 이벤트객체중 생성자 함수는 이
- 이벤트가 발생하면 생성되는 이벤트 객체도 생성자 함수에 의해 생성되며 생성자 함수와 더불어 생성되는 프로토타입으로 구성된 프로토타입 체인의 일원이 된다. 
- 이벤트 중 일부는 사용자의 행위에 의해 생성된 것이고 일부는 자바스크립트 코드에 의해 인위적으로 생성된 것이다.
-  이벤트 객체의 프로퍼티는 발생한 이벤트의 타입에 따라 달라진다.
- 이벤트 타입에 따라 고유한 프로퍼티가 정의되어 있다

### 5.2이벤트 객체의 공통 프로퍼티

- Event.prototype에 정의되어 있는 이벤트 관련 프로퍼티는 모든 파생 이벤트 객체에 상속된다. 

### 5.3마우스 정보 취득

- [MouseEvent](https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent) 타입의 이벤트 객체는 아래와 같은 고유의 프로퍼티를 갖는다.
  - 마우스 포인터의 좌표 정보를 나타내는 프로퍼티: screenX/screenY, clientX/clientY, pageX/pageY, offsetX/offsetY
  - 버튼 정보를 나타내는 프로퍼티: altKey, ctrlKey, shiftKey, button

### 5.4키보드 정보취득

 [KeyboardEvent](https://developer.mozilla.org/en-US/docs/Web/API/keyboardEvent) 타입의 이벤트 객체는 altKey, ctrlKey, shiftKey, metaKey, key, keyCode와 같은 고유의 프로퍼티를 갖는다.

## 6.이벤트 전파

- DOM 트리 상에 존재하는 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해 전파된다. 이를 이벤트 전파(event propagation)라고 한다. 
- . 이벤트 전파는 이벤트 객체가 전파되는 방향에 따라 아래와 같이 3단계로 구분할 수 있다.
  - 캡처링 단계(capturing phase) : 이벤트가 상위 요소에서 하위 요소 방향으로 전파
  - 타깃 단계(target phase) : 이벤트가 이벤트 타깃에 도달
  - 버블링 단계(bubbling phase) : 이벤트가 하위 요소에서 상위 요소 방향으로 전파
- 이벤트 핸들러는 기본적으로 타깃 단계와 버블링 단계의 이벤트를 캐치한다.
- 이벤트 핸들러 어트리뷰트/프로퍼티 방식으로 등록한 이벤트 핸들러는 타깃 단계와 버블링 단계의 이벤트만을 캐치할 수 있다.
- 이벤트 핸들러 어트리뷰트/프로퍼티 방식으로 등록한 이벤트 핸들러는 타깃 단계와 버블링 단계의 이벤트만을 캐치할 수 있다.(캡처링 단계의 이벤트를 캐치하려면 addEventListener 메소드의 3번째 인수로 true를 전달해야 한다. 3번째 인수를 생략하거나 false를 전달하면 타깃 단계와 버블링 단계의 이벤트만을 캐치할 수 있다.)
- 이벤트 패스는 Event.prototype.composedPath 메소드로 확인할 수 있다.

## 7.이벤트 위임

## 8.기본동작의 변경

### 8.1기본 동작 중단

- DOM 요소의 저마다의 기본 동작이 있다. 
- 이벤트 객체의 preventDefault 메소드는 이러한 DOM 요소의 기본 동작을 중단시킨다.

### 8.2이벤트 전파 방지

- 이벤트 객체의 stopPropagation 메소드는 이벤트 전파를 중지시킨다. 

- 이처럼 상위 요소와 하위 요소의 이벤트를 각각 별도로 처리하기 위해 이벤트의 전파를 중단시키기 위해서 stopPropagation 메소드를 사용한다.

## 9.이벤트 핸들러 내부의 this

### 9.1이벤트 핸들러 어트리뷰트 방식

이벤트 핸들러 어트리뷰트 방식의 경우, 이벤트 핸들러 내부의 this는 전역 객체 window를 가리킨다.

### 9.2. 이벤트 핸들러 프로퍼티 방식과 addEventListener 메소드 방식

- this는 이벤트를 바인딩한 DOM 요소를 가리킨다. 즉, 이벤트 객체의 currentTarget 프로퍼티와 같다.
- 클래스에서 이벤트 핸들러를 바인딩하는 경우, this에 주의해야 한다. 

## 10.이벤트 핸들러에 인수 전달

- 이벤트 핸들러 내부에서 함수를 호출하면서 인수를 전달할 수 있다.
- 또는 이벤트 핸들러를 반환하는 함수를 호출하면서 인수를 전달할 수도 있다.

## 11.커스텀 이벤트

### 11.1. 커스텀 이벤트 생성

-  “35.2. 이벤트 타입”에서 살펴본 이벤트 타입 이외의 이벤트를 생성할 수 있다. 이를 커스텀 이벤트라 한다.
- 이벤트 생성자 함수의 인수로 전달하는 이벤트 타입은 기존 이벤트 타입(“35.2. 이벤트 타입” 참고)을 사용할 수 있다.

### 11.2커스텀 이벤트 디스패치

생성된 커스텀 이벤트는 dispatchEvent 메소드로 디스패치(이벤트를 발생시키는 행위)할 수 있다.